# -*- coding: utf-8 -*-
"""0719clustering.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-EZDhLaNkwN5QrpjQi8sPWur3v3x60Tl
"""

!pip install kmodes

import pandas as pd

df = pd.read_csv('2022외래관광객조사.csv', encoding="euc-kr")
display(df)

from kmodes.kmodes import KModes
import numpy as np
import matplotlib.pyplot as plt

#df_selected = df[['RQ2A2', 'Q3B1', 'D_AGE', 'Q4B1', 'D_MON_season']]
df_selected= df[['Q3B1','D_AGE','RQ2A2','D_MON_season']]
cost = []
for num_clusters in list(range(1,10)):
    kmode = KModes(n_clusters=num_clusters, init="Cao", n_init=1, verbose=1)
    kmode.fit_predict(df_selected)
    cost.append(kmode.cost_)

y = np.array([i for i in range(1,10,1)])
plt.plot(y,cost)

# 필요한 컬럼들만 추출
df_selected= df[['Q3B1','D_AGE','RQ2A2','D_MON_season']]

# K-Modes 클러스터링
km = KModes(n_clusters=3, init='Cao', n_init=10, verbose=1)
clusters = km.fit_predict(df_selected)

# 클러스터 결과를 원래 DataFrame에 추가
df['cluster'] = clusters

# 각 클러스터의 중심점 확인
for i in range(3):
    print(f"Cluster {i} characteristics:")
    print(km.cluster_centroids_[i])

'''# 'Q4A01'~'Q4A17'의 열들에서 각 클러스터별로 가장 많이 한 활동 상위 5개 찾기
for i in range(3):
    print(f"\nCluster {i} top 5 활동 및 빈도수:")
    activities = pd.Series(dtype='int')  # 각 클러스터의 활동 코드와 빈도를 저장할 Series

    # 'Q4A01'~'Q4A17'의 각 열을 순회하면서 가장 빈번한 활동 코드를 찾습니다.
    for j in range(1, 18):  # 'Q4A01'~'Q4A17'
        column_name = f'Q4A{j:02d}'  # 현재 열의 이름
        cluster_i = df[df['cluster'] == i][column_name]  # 현재 클러스터의 현재 열
        cluster_i = cluster_i.dropna()  # 빈 값 제거
        activities = activities.append(cluster_i.value_counts(), ignore_index=False)  # 현재 열의 값들을 Series에 추가

    # 추가한 값들 중 가장 빈번한 상위 5개 활동 코드를 출력합니다.
    top_5_activities = activities.groupby(activities.index).sum().nlargest(5)
    for activity, frequency in top_5_activities.items():
        print(f"Activity {activity}: {frequency} times")'''

  # 'Q4B1' 열에서 각 클러스터별로 가장 만족한 활동 상위 5개 찾기
for i in range(3):
    print(f"\nCluster {i} top 5 만족한 활동 및 빈도수:")
    cluster_i = df[df['cluster'] == i]['Q4B1']  # 현재 클러스터의 'Q4B1' 열
    cluster_i = cluster_i.dropna()  # 빈 값 제거

    # 현재 클러스터에서 가장 만족한 상위 5개 활동 코드와 빈도를 출력합니다.
    top_5_satisfied_activities = cluster_i.value_counts().nlargest(5)
    for activity, frequency in top_5_satisfied_activities.items():
        print(f"Activity {activity}: {frequency} times")

# 각 클러스터별 전체적인 분포 출력
cluster_counts = df['cluster'].value_counts()
print("\nOverall distribution of clusters:")
for cluster, count in cluster_counts.items():
    print(f"Cluster {cluster}: {count} rows")

import matplotlib.pyplot as plt
import seaborn as sns

# 각 클러스터의 상위 5개 활동을 담을 빈 리스트를 생성
top_5_activities_clusters = []

for i in range(5):
    activities = []  # 각 클러스터의 활동 코드와 빈도를 저장할 리스트

    for j in range(1, 18):  # 'Q4A01'~'Q4A17'
        column_name = f'Q4A{j:02d}'  # 현재 열의 이름
        cluster_i = df[df['cluster'] == i][column_name]  # 현재 클러스터의 현재 열
        cluster_i = cluster_i.dropna()  # 빈 값 제거
        activities.append(cluster_i.value_counts())  # 현재 열의 값들을 리스트에 추가

    activities = pd.concat(activities)
    top_5_activities = activities.groupby(activities.index).sum().nlargest(5)
    top_5_activities_clusters.append(top_5_activities)

# 각 클러스터의 상위 5개 활동을 시각화
for i in range(3):
    plt.figure(figsize=(10, 5))
    sns.countplot(x=top_5_activities_clusters[i].index, data=df, order=top_5_activities_clusters[i].index)
    plt.title(f'Cluster {i} Top 5 Activities')
    plt.xlabel('Activity Code')
    plt.ylabel('Frequency')
    plt.show()

import matplotlib.pyplot as plt

# 각 클러스터의 상위 5개 활동을 시각화
for i in range(5):
    plt.figure(figsize=(10, 5))
    plt.bar(top_5_activities_clusters[i].index, top_5_activities_clusters[i].values)
    plt.title(f'Cluster {i} Top 5 Activities')
    plt.xlabel('Activity Code')
    plt.ylabel('Frequency')
    plt.show()

"""밑에는 cluster 3으로"""

# 필요한 컬럼들만 추출
df_selected = df[['RQ2A2', 'Q3B1', 'D_AGE', 'Q4B1', 'D_SEX']]

# K-Modes 클러스터링
km = KModes(n_clusters=3, init='Huang', n_init=10, verbose=1)
clusters = km.fit_predict(df_selected)

# 클러스터 결과를 원래 DataFrame에 추가
df['cluster'] = clusters

# 각 클러스터의 중심점 확인
for i in range(3):
    print(f"Cluster {i} characteristics:")
    print(km.cluster_centroids_[i])

# 'Q4A01'~'Q4A17'의 열들에서 각 클러스터별로 가장 많이 한 활동 상위 5개 찾기
for i in range(3):
    print(f"\nCluster {i} top 5 활동 및 빈도수:")
    activities = pd.Series(dtype='int')  # 각 클러스터의 활동 코드와 빈도를 저장할 Series

    # 'Q4A01'~'Q4A17'의 각 열을 순회하면서 가장 빈번한 활동 코드를 찾습니다.
    for j in range(1, 18):  # 'Q4A01'~'Q4A17'
        column_name = f'Q4A{j:02d}'  # 현재 열의 이름
        cluster_i = df[df['cluster'] == i][column_name]  # 현재 클러스터의 현재 열
        cluster_i = cluster_i.dropna()  # 빈 값 제거
        activities = activities.append(cluster_i.value_counts(), ignore_index=False)  # 현재 열의 값들을 Series에 추가

    # 추가한 값들 중 가장 빈번한 상위 5개 활동 코드를 출력합니다.
    top_5_activities = activities.groupby(activities.index).sum().nlargest(5)
    for activity, frequency in top_5_activities.items():
        print(f"Activity {activity}: {frequency} times")

# 각 클러스터별 전체적인 분포 출력
cluster_counts = df['cluster'].value_counts()
print("\nOverall distribution of clusters:")
for cluster, count in cluster_counts.items():
    print(f"Cluster {cluster}: {count} rows")

import matplotlib.pyplot as plt
import seaborn as sns

# 각 클러스터의 상위 5개 활동을 담을 빈 리스트를 생성
top_5_activities_clusters = []

for i in range(5):
    activities = []  # 각 클러스터의 활동 코드와 빈도를 저장할 리스트

    for j in range(1, 18):  # 'Q4A01'~'Q4A17'
        column_name = f'Q4A{j:02d}'  # 현재 열의 이름
        cluster_i = df[df['cluster'] == i][column_name]  # 현재 클러스터의 현재 열
        cluster_i = cluster_i.dropna()  # 빈 값 제거
        activities.append(cluster_i.value_counts())  # 현재 열의 값들을 리스트에 추가

    activities = pd.concat(activities)
    top_5_activities = activities.groupby(activities.index).sum().nlargest(5)
    top_5_activities_clusters.append(top_5_activities)

# 각 클러스터의 상위 5개 활동을 시각화
for i in range(3):
    plt.figure(figsize=(10, 5))
    sns.countplot(x=top_5_activities_clusters[i].index, data=df, order=top_5_activities_clusters[i].index)
    plt.title(f'Cluster {i} Top 5 Activities')
    plt.xlabel('Activity Code')
    plt.ylabel('Frequency')
    plt.show()

#하는 의미가...ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ



from sklearn.decomposition import PCA

# 2차원으로 차원 축소
pca = PCA(n_components=2)
pca_result = pca.fit_transform(df_selected.values)

# 결과를 데이터프레임에 추가
df_selected['pca-one'] = pca_result[:,0]
df_selected['pca-two'] = pca_result[:,1]

# 클러스터링 결과를 데이터프레임에 추가
df_selected['cluster'] = clusters

# 시각화
sns.scatterplot(
    x="pca-one", y="pca-two",
    hue="cluster",
    palette=sns.color_palette("hsv", len(set(clusters))),
    data=df_selected,
    legend="full",
    alpha=0.8
)